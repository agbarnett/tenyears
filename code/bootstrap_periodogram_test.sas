/****************************************************************/
/*    NAME: bootstrap_periodogram_test.sas                      */
/*   TITLE: Test residuals using a bootstrap test to look for   */
/*          remaining seaosonal patterns                        */
/*    DATA: Example data generated in program                   */
/*   PROCS: GPLOT, SPECTRA, UNIVARIATE                          */
/*  AUTHOR: Adrian Barnett (a.barnett@qut.edu.au)               */
/*     REF: Barnett and Dobson, Stats in Medicine 2004          */ 
/*                                                              */
/****************************************************************/

**** ;
* Generate bootstrap data from the observed errors;
%macro bootloop;
data work.boot;
   set work.posterior(keep=dummy errs time);
   order=uniform(0);
run;
* Re-order the data;
proc sort data=work.boot;
   by order;
run;
proc spectra data=work.boot s p adjmean coef out=work.respec(keep=period p_01 cos_01 sin_01 dummy s_01);
   by dummy;
   var errs;
   weights 0.1464466 0.5 0.8535534 1 0.8535534 0.5 0.1464466; * Hanning window, bandwidth=3;
run;
proc append base=work.allboot data=work.respec;
run;
%mend bootloop;

%macro runboot;
   %do count=1 %to 1000; * Number of bootstrap loops;
   %bootloop;
   %end;
%mend runboot;

* Macro to run entire bootstrap test;
%macro boottest;
data work.allboot;
   period=0; p_01=0; cos_01=0; sin_01=0; dummy=0; s_01=0;
run;
options nonotes nomprint;
%runboot;
options notes mprint;
* Remove dummy data from bootstrap;
data work.removex(drop=cos_01 sin_01);
   set work.allboot;
   if (period>=2 and period<=24); *<- Limited to 2 years (24 months);
   r=sqrt((cos_01**2)+(sin_01**2));*<-Calculate amplitude;
run;
proc sort data=work.removex;
   by dummy descending period;
run;
* Calculate the actual periodogram;
proc spectra data=work.posterior out=work.realx adjmean p coef s;
   by dummy;
   var errs;
   weights 0.1464466 0.5 0.8535534 1 0.8535534 0.5 0.1464466; * Hanning window, bandwidth=3;
run;
data work.real(drop=cos_01 sin_01);
   set work.realx;
   if period>=2 and period<=24;
*   if period>=10 and period<=14; * Test for annual frequency;
   r=sqrt((cos_01**2)+(sin_01**2));*<-Calculate amplitude;
run;
* Get the bootstrap limits;
proc univariate data=work.removex noprint;
   by dummy descending period;
   var r; *s_01; 
   output out=work.bootupper pctlpts=95 pctlpre=p pctlname=y; *Using alpha=5%;
run;
proc univariate data=work.removex noprint;
   by dummy descending period;
   var s_01; * Get the spectrum limits also;
   output out=work.bootupper2 pctlpts=95 pctlpre=p pctlname=y;
run;
* Merge in actual periodogram;
data work.actual;
   merge work.real work.bootupper(in=a);
   by dummy descending period;
   if a;
run;
data work.actual2;
   merge work.real work.bootupper2(in=a);
   by dummy descending period;
   if a;
run;
** Plot;
goptions reset=all ftext=centx htext=3 gunit=pct colors=(black) border;
*title;
symbol1 color=black value=NONE i=join line=2 width=4;
symbol2 color=black value=NONE i=join;
axis1 minor=NONE label=(h=3 ' ') order=(2 to 24 by 2); *<-period;
axis2 minor=NONE label=(h=3 a=90 ' '); *<-amplitude;
proc gplot data=work.actual;
   plot py*period=1 r*period=2 / overlay noframe haxis=axis1 vaxis=axis2;
* Subscripts;
   note m=(45,1.5)pct h=3 'Period (f' m=(-1.5,-.75) h=1.75 'j';
   note m=(62.0,1.5) h=3 ')';
   note m=(3,54.5)pct h=3 angle=90 '^';
   note m=(3.25,55) angle=90 h=3  'a';
   note m=(4,56.5) angle=90 h=1.75  'j';
run; quit;
goptions reset=all ftext=centx htext=3 gunit=pct colors=(black) border;
symbol1 color=black value=NONE i=join line=2 width=4;
symbol2 color=black value=NONE i=join;
axis1 minor=NONE label=(h=3 'f') order=(2 to 24 by 2); *<-period;
axis2 minor=NONE label=(h=3 a=90 's'); 
proc gplot data=work.actual2;
   plot py*period=1 s_01*period=2 / overlay noframe haxis=axis1 vaxis=axis2;
run; quit;
* Find significant frequencies;
data work.sig work.estvar;
   set work.actual;
   if r>py then do;
      dummy=1;
      pround=round(period,0.1);
	  output work.sig;
   end;
   else do;
      peri=p_01*2; *rescale;
      output work.estvar;
   end;
run;
* Get sum of squares for non=periodic terms;
proc univariate data=work.estvar noprint;
   var peri;
   output out=work.sumerr sum=sum; * Sum I(w);
run;
title "Significant amplitudes according to periodogram";
proc print data=work.sig noobs label;
   var pround py r;
   label pround='Period' py='limit' r='Amplitude'; *s_01='Sample spectrum';
   format py r 6.3;
run;

** Added from bootperi, used to estimate noise variance;
* Find significant frequencies;
data work.sig work.estvar;
   set work.actual;
   dummy=1;
   if r > py then do;
      pround=round(period,0.1);
	  output work.sig;
   end;
   else do;
      output work.estvar;
   end;
run;
* Get sum of squares for non=periodic terms;
proc univariate data=work.estvar noprint;
   by dummy;
   var p_01;
   output out=work.sumerr sum=sum n=nord; * Sum I(w);
run;
* Get data length;
proc univariate data=work.posterior noprint;
   by dummy;
   var centre;
   output out=work.length n=n;
run;
data work.varest;
   merge work.sumerr(in=a) work.length;
   by dummy;
   if a;
   m=(n/2);
   sumres=(sum/nord)*m; * Rescale sum;
   stdest=sqrt(sumres/n);* Sigma hat;
run;
*%cntrname(&centre.,&runit.); * adds centre name, turned off;
proc print data=work.varest noobs label;
   var sum n stdest;
   label sum='Sum of squares' n='n' stdest='Sigma estimate (periodogram)';
   format sum stdest 6.1;
run;

%mend boottest;
